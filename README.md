# Panda Flower - Backend

**엘리스 SW 트랙 6기 1차 프로젝트** <br>
쇼핑몰 웹 서비스 제작 프로젝트 <br>

<br>

## 1. 프로젝트 기간 & 인원

- 프로젝트 기간: 약 2주 (2023.10.02 ~ 2023.10.13)
- 개발 인원:  
  `Frontend`: 임정훈, 주효원, 김수환 <br>
  `Backend`: 김영운, 이정혜, 김영욱 <br>

<br>

## 2. 사용 기술

- **BackEnd** <br>

  JavaScript <br>
  Node.js <br>
  express <br>
  passport <br>
  mongoDB <br>
  mongoose <br>
  Rest API <br>
  배포: NginX, PM2, GCP

<br>

- **협업** <br>

  Git & Git lab <br>
  Postman <br>
  discord <br>
  Notion <br>
  Gather <br>
  Figma

<br>

## 3. 핵심 기능

쇼핑몰 웹사이트의 핵심 기능으로 크게 `사용자 관련`, `상품 관련`, `장바구니 관련`, `주문 관련` 기능을 구현하였습니다.

<br>

## 4. 내가 맡은 기능

1. 사용자 관련 기능 <br>
2. 장바구니 관련 기능 <br>
3. 주문 관련 기능 <br>

<br>

# 📍 사용자 관련 기능

<br>

**1. 회원가입**

- 회원가입 폼의 입력 값이 빈값으로 들어올 시 키에러를 반환합니다. (프론트에서 사용자에게 알려주기 위해 어떤 값이 빈값인지 해당하는 키에러를 반환)
- 정규표현식을 사용하여 이메일, 비밀번호, 핸드폰 번호의 유효성을 검증합니다. (이메일 - elice@elice.com / 비밀번호 - 최소 8자 이상, 대소문자 상관없이 적어도 영문 하나 포함, 적어도 숫자 하나 포함, 적어도 특수문자 하나 포함 / 핸드폰 번호 - 010-0000-0000)
- 비밀번호 입력값과 비밀번호 확인 입력값이 일치하는지 검증한 후 불일치 시 에러 메시지를 반환합니다.
- 기 가입된 이메일로 중복 가입 시도 시 가입이 불가하도록 에러 메시지를 반환합니다.
- 회원가입 성공시 사용자 정보를 유저 DB에 저장합니다. 이때 bcrypt를 사용하여 비밀번호는 암호화를 진행한 후 DB에 저장합니다.

<br>

**2. 로그인**

- 사용자가 입력한 이메일이 DB에 있는지 확인 후 없을 시 에러 메시지를 반환합니다.
- DB내 저장된 암호화 된 비밀번호와 사용자가 입력한 비밀번호를 bcrypt로 비교 후 불일치 시 에러 메세지를 반환합니다.
- jwt를 활용하여 로그인 성공 시 payload에 userId, isAdmin이 담긴 accessToken을 발급합니다.

<br> 
  
**3. 인가(Authorization)**
- `마이페이지`, `장바구니`, `주문`, `결제` 기능 이용 시 accessToken을 복호화하여 payload의 userId 확인 후 가입된 고객만 접근이 가능하도록 인가 middleware를 구현했습니다.
- payload 내 userId가 DB에서 확인되지 않을 경우 유효하지 않은 user라는 에러 메시지를 반환합니다.

<br>

**4. 마이페이지**

- **사용자 정보 조회:** 사용자는 개인 페이지에서 자신의 회원 정보를 조회할 수 있습니다. 인가 middleware를 이용해서 accessToken을 복호화하여 payload에 담겨 있는 userId를 가져와 해당 ID로 DB에서 일치하는 ID의 사용자 정보를 가져옵니다.

- **사용자 정보 수정:** 사용자는 개인 페이지에서 자신의 회원 정보(비밀번호, 주소)를 수정할 수 있습니다. accessToken의 payload에서 userId를 확인하고 req.body로 수정할 데이터를 전달 받아서 해당 사용자의 정보를 수정합니다.

- **사용자 정보 삭제:** 사용자는 개인 페이지에서 자신의 회원 정보를 삭제(탈퇴)할 수 있다. 전달 받은 accessToken를 복호화하여 payload 안에 담겨 있는 userId를 활용해 DB에서 일치하는 사용자 document를 찾아서 삭제합니다.

<br>

# 📍 장바구니 관련 기능

**장바구니 CRUD**

- **조회:** 사용자는 장바구니에 담긴 상품 목록을 확인할 수 있다. accessToken을 확인하여 해당 유저의 오브젝트 ID를 추출하여 카트 컬렉션에서 해당 ID 등록된 장바구니 상품을 찾아서 보여줍니다.

- **생성:** 사용자는 상품을 장바구니에 추가할 수 있다. accessToken에서 추출한 사용자의 오브젝트 ID를 활용하여 해당 사용자의 장바구니 목록을 가져옵니다. 장바구니가 비어있다면 req.body로 전달 받은 아이템 ID와 수량을 사용자의 ID와 함께 카트 컬렉션에 생성합니다. 만약 장바구니가 비어있지 않다면 불러온 장바구니 목록에서 동일한 상품이 있는지 확인하고 동일한 상품이 있을 경우 해당 상품의 수량만 증가하도록 합니다.

- **수정:** 사용자는 장바구니에 속한 상품의 수량을 수정할 수 있습니다. 수정할 아이템의 ID와 수량를 req.body로 전달 받아 accessToken에서 추출한 사용자의 ID와 아이템 ID를 활용해 둘다 일치하는 장바구니 상품을 찾아서 수량을 업데이트합니다.

- **삭제:** 사용자는 장바구니에서 버튼 1번의 클릭으로, 장바구니 전체 상품을 제거할 수 있습니다. accessToken에서 추출한 사용자 오브젝트 ID로 등록된 장바구니 상품들을 카트 컬렉션에서 전부 삭제합니다. 사용자는 장바구니에서 일부 상품을 골라서 제거할 수 있습니다. 만약 req.body로 전달 받은 상품 ID가 있다면 해당 상품만 카트 컬렉션에서 삭제합니다. req.body로 전달받은 상품이 없다면 전체 삭제합니다.

<br>

# 📍 주문 관련 기능

## • 사용자

- **주문하기:** 사용자는 장바구니에 속한 상품들로 주문을 진행할 수 있습니다.
- **주문수정:** 사용자는 주문 완료 후 배송이 시작되기 전까지 주문 정보를 수정할 수 있습니다. 결제완료 하면 생성되는 주문 번호를 패스 파라미터에 담아서 요청합니다. req.params로 주문번호를 가져오고 req.body로 수정할 배송지 데이터(받는 사람, 연락처, 주소)를 전달 받습니다. 주문번호를 이용하여 Oder 켈렉션에서 해당 주문을 찾아 업데이트 합니다. 단 배송상태가 주문완료일 경우에만 수정이 가능합니다.
- **결제완료:** 결제 완료 시, 주문 완료 페이지로 이동합니다. recipient, contact, shippingAddress, totalPrice, items 받는 사람, 연락처, 배송지, 최종 금액, 주문 상품을 req.body로 전달 받아 Order 컬렉션에 저장합니다. 이때 배송상태는 주문완료, 주문번호는 uuid를 이용하여 생성 후 함께 저장합니다.
- **주문조회:** 사용자는 개인 페이지에서 자신의 주문 내역을 조회할 수 있습니다. 요청 헤더에 담긴 accessToken를 복호화 하여 userId를 추출해 해당 ID로 사용자를 찾고 사용자의 오브젝트 ID를 통해 주문 정보를 찾을 수 있습니다.
- **주문취소:** 사용자는 개인 페이지에서 자신의 주문 내역을 취소할 수 있다. 패스파리미터에 주문번호를 담아서 요청하면 req.params로 주문번호를 추출해 해당 주문번호로 주문 DB에서 일치하는 주문정보를 찾아 삭제합니다. 단, 삭제할 주문의 배송상태가 주문완료일 경우에만 삭제가 가능합니다.
- **주문정보:** DB에 주문번호, 배송상태, 받는사람, 연락처, 배송지, 주문 총액, 사용자 오브젝트 ID, 상품이 저장됩니다.

  <br>

## • 관리자

- **주문조회:** 관리자는 관리 페이지에서 사용자들의 주문 내역을 조회할 수 있다. validateAdmin 미들웨어를 통해 accessToken의 payload에 담겨 있는 isAdmin의 값이 true인 경우에만 통과하여 Order 컬렉션의 모든 주문 내역을 조회할 수 있습니다.
- **주문수정:** 관리자는 사용자의 주문 내역에서 배송 상태를 수정할 수 있다. validateAdmin 미들웨어를 통해 관리자 계정이 확인되어야 사용자들의 주문에 접근하여 배송 상태를 수정할 수 있습니다.
- **주문삭제:** 관리자는 관리 페이지에서 사용자들의 주문 내역을 삭제할 수 있다. validateAdmin 미들웨어를 통해 관리자 계정이 확인되어야 사용자들의 주문에 접근하여 주문을 취소할 수 있습니다.

<br>

# 📍 폴더 구조

**Layered Pattern**
![캡처](https://user-images.githubusercontent.com/126956430/276858664-0478fa17-5ef0-4f47-bbf1-e1423af26e46.png)

`단방향 의존성`과 `관심사 분리` 라는 두가지 핵심 원리에 기반하여 폴더 구조를 구성했습니다.

App → Router → Controller → Service → Models 순으로 갈수록 데이터베이스의 접근에 가까워 집니다.

- **App.js:** Express App 으로 서버를 여는 로직입니다. 그리고 Express App 인스턴스를 만들고, 필요한 미들웨어를 붙이는 로직입니다.
- **routes:** 라우팅(엔드 포인트 나누기) 로직을 담당합니다.
- **controllers:** 엔드포인트에 해당하는 함수 로직 - http 요청에 따른 에러 핸들링, service 로직에서 데이터를 받아와서 응답으로 내보내는 로직입니다
- **services:** controller 에서 넘겨받은 인자로 다양한 알고리즘(필터, 정렬 등..)을 처리해서 데이터에 접근하는 로직입니다.
- **models:** 데이터베이스에 접근하기 위한 모델(DAO)이 정의되어 있는 폴더입니다.
- **utils:** 의존성 없이 모든 레이어에서 공통적으로 자주 사용되는 로직을 모듈화 해 놓는 폴더입니다.
- **middlewares:** 컨트롤러에 닿기 전에 반복되는 로직을 모듈화 해 놓는 폴더입니다. (ex. validateToken - 인증 / 인가)
  <br>

# 📍 트러블 슈팅

**1. CORS 에러**
![캡처](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8fbc1ff5-5975-4835-80cd-07491048c01a%2FUntitled.png?table=block&id=b06214ad-d9f4-42e5-be8f-e374d6b5e1cd&spaceId=530d1033-cf9f-41a2-b140-62d3e90887dd&width=1610&userId=b15b8061-acc6-470a-855e-73b04ad1a384&cache=v2)

- CORS 는 Cross Origin Resource Sharing 의 약자로, **Domain 주소가 다를 때** ( = Origin이 다를 때 = Cross Origin 일 때), http 요청 (Resource Sharing) 을 어떻게 처리하는가에 대한 규약입니다.
- **동일한 localhost 라도, port 번호가 다르면 (3000, 5000 등) 다른 Domain** 입니다.
- 일반적으로 Domain 주소가 다르면, 보안을 위해 resource 요청을 수용하지 않아야 합니다.
- 따라서 서버는, 다른 Domain 에서 요청이 왔을 때 이 요청을 수용하는지 안 하는지 대답을 해 주어야 합니다. 이 대답은 서버가 브라우저에 응답할 때의 Response Header 의 {ACCESS-CONTROL-ALLOW-ORIGIN: ~~} 형태로 주게 됩니다.
- 이 때 ~~ 부분에 요청 Domain 이 포함되어 있거나 혹은 \* 로 표시했을 경우, 요청을 수용하겠다는 의미이며, 별도 헤더 표시가 없는 경우는 수용하지 않겠다라는 의미입니다. 이 경우 CORS 에러가 발생합니다.

- ### 해결 방법

1. `npm install cors` 를 통해 cors 모듈을 설치합니다.
2. express 서버를 시작하는 코드가 담긴 app.js 에서 `import cors from “cors”` 를 합니다.
3. `app.use(cors())` 를 통해 express 에 cors 객체를 연결합니다.

**2. Authorization 에러**

- Authorization 헤더에서 "Bearer"를 생략해서 HTTP 요청에서 인증 정보를 정확하게 식별할 수 없기 때문에 서버에서 오류가 발생했습니다. 포스트맨으로 테스트 했을 때는 인증이 정상적으로 되는데 프론트에서 HTTP 요청을 보내면 자꾸 에러가 발생했습니다. 이유를 모르겠어서 포스트맨에서는 Bearer Token을 선택해서 토큰을 담아주기에 프론트엔드 담당하시는 분께 토큰 앞에 Bearer를 붙여보라고 했더니 정상적으로 인증이 되었습니다.
- `Bearer`는 토큰의 유형을 나타내고, 이것이 없으면 서버는 어떤 종류의 인증 토큰이 제공되었는지 알 수 없습니다. 따라서 "Bearer"를 생략하지 않고 인증 토큰을 올바르게 전달해야 합니다.

**3. OBJECT ID 비교**

- 오브젝트 ID를 추출하여 해당 ID를 가지고 DB에 있는 데이터에 접근하려고 할 때 정상적으로 접근이 되지 않았습니다. 그 이유는 추출한 오브젝트 ID는 타입이 문자열이고 DB에 저장되어 있는 오브젝트 ID는 MongoDB에서 고유한 데이터 형식이기 때문이었습니다. 해당 문제를 해결하기 위해서는 추출한 문자열 타입의 ID를 ObjectId로 변환하고 비교해야합니다.

# 📍 느낀점/회고

> 엘리스 1차 프로젝트 회고:블로그 주소
